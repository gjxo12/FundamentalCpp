#include<iostream>

//정의: 객체를 만든다! -> 메모리를 할당하겠다!
//스택: 지역, 함
//데이터 영역: 전역

class CTest {
public:
	int m_value;
	int mFuc(int a) {
		return a;
	}

};
// ,클래스의 가장 큰 차이점은 일반 변수들과 다르게 메모리가 컴파일러가 사용하는 메모리임
// 일반은 가상 메모리

// 선언: 정의된 즉 메모리 영역을 차지하는 객ㅊ테가 생성되었지만, 존재를 모른다.
// 선언은 어떤 객체가 존재함을 알린다.
// 결국 정의와 선언은 같이 이루어진다. 하지만!? 다른 소스 파일에서 이미 정의도ㅓㅣㄴ 객체를 사용하고자 할떈 순수하게 선언만
// 그래야 중복을 피한다. -> 안그러면 링크 에러~~

//extern, static

extern int g_val;
extern int s_val;
class ClassTest;

int main()
{
	g_val = 1; // 
	s_val = 2; // 링크에러!
	std::cout << g_val << "  " << s_val << "\n";
	// extern: 다른 소스파일에도 사용하도록 링크 <-> static

	//ClassTest ct;  Error... 컴파일러는 오직 소스파일 단위로만 독립적으로 컴파일한다!! 
	//ct.m_val;            컴파일러는 해당 클래스가 어떤 크기와 맴버를 가지고 있는지 모름...
	// 그래서 클래스를 헤더 파일에 작성하고! 소스파일에 포함시키는 방식을 사용!!


	//변수와 초기화
	//정적, 전역: 초기화하지 않은것과 상수가 먼저 다음에 함수의 반환을 통한 초기화 진행 -> 데이터 영역이라는거!!
	// 초기값은 가상 메모리에 될텐데 1이면 가상 메모리가 구성되는 시점에 메모리가 다 1로 채워짐 
	// 반면에 그외에는 BSS영역에 싹다 0,NULL

	//p112 부터는 vscode -정적 변수-

	return 0;
}